---
name: cross-module-workflow
description: 执行跨模块功能的 Vibe Coding 开发工作流，按步骤开发、测试验证、更新主文档和模块引用。当用户说"开始跨模块 Step"、"跨模块继续开发"、"执行跨模块下一步"、"按跨模块计划开发"时自动激活
---

# 跨模块开发工作流

> **核心理念**："规划就是一切。不要让 AI 自主规划，否则你的代码库会变成一团乱麻。"

## 何时使用

- 用户说"开始跨模块 Step X"
- 用户说"跨模块继续开发"
- 用户说"执行跨模块下一步"
- 用户说"按跨模块计划开发"

**前提条件**：使用此工作流前，必须已通过 `cross-module-docs-guide` 创建 `docs/features/[功能名]/` 文档。

## 开始前必做（铁律）

**在开始编码前，必须先阅读以下文档：**

### 1. 顶层规范文档（每次开发都要阅读）

- `CLAUDE.md` - 最高开发规范（三层架构、依赖规则、开发原则）
- `PROJECT_OVERVIEW.md` - 项目架构概览（模块清单、当前状态）

### 2. 跨模块主文档

- `docs/features/[功能名]/prd.md`（跨模块完整需求）
- `docs/features/[功能名]/implementation-plan.md`（分步实现计划）
- `docs/features/[功能名]/progress.md`（了解之前完成的工作）
- `docs/features/[功能名]/architecture.md`（了解当前架构）

### 3. 涉及模块的 memory-bank

根据 prd.md 中列出的模块，阅读每个模块的：
- `products/xxx/memory-bank/prd.md`（模块自身需求）
- `products/xxx/memory-bank/architecture.md`（模块架构）
- `products/xxx/memory-bank/cross-module-refs.md`（本功能在该模块的职责）

如果 implementation-plan.md 不够清晰，**必须向用户提问澄清**。

## 执行单个 Step 的标准流程

```
1. 阅读跨模块主文档 + 相关模块 memory-bank
2. 查看 progress.md 了解之前完成的工作
3. 确认当前 Step 属于哪个 Phase（infrastructure → services → products）
4. 执行 implementation-plan.md 的 Step [N]
5. 只做当前步骤要求的内容，不要超前
6. 如果有疑问，先问用户
7. 告知用户如何测试
8. 等待测试结果，测试通过前不开始下一步
```

**开发顺序（铁律）**：infrastructure → services → products，禁止跳过下层直接开发上层。

## 测试验证

| 测试结果 | Claude 操作 |
|----------|-------------|
| 测试通过 | 更新主文档 + 模块引用，告知可继续下一步 |
| 测试失败 | 分析错误原因并修复，不继续下一步 |

**跨模块额外验证**：模块间数据传递、API 调用、事件发布/订阅、共享服务状态。

## 文档更新模板

### 主文档 progress.md 每步完成后追加：

```markdown
---

## Step [N]: [步骤标题]

**完成时间:** YYYY-MM-DD HH:MM
**版本号:** vX.X.X
**所属模块:** [infrastructure/services/products]/xxx

**完成内容:**
- [具体做了什么]
- [创建/修改了哪些文件]

**测试结果:**
- ✅ [测试项1] 通过
- ✅ [测试项2] 通过

**模块间交互验证:**
- ✅ [模块A] → [模块B] 数据传递正常

**备注:**
- [遇到的问题及解决方案]
```

### 主文档 architecture.md 每新增文件后追加：

```markdown
---

## [所属模块]: [文件路径]

**用途:** [这个文件做什么]

**主要函数/组件:**
- `functionName()` - 功能描述

**跨模块交互:**
- 调用: [调用哪些其他模块的接口]
- 被调用: [被哪些其他模块调用]
```

### 模块 cross-module-refs.md 涉及文件更新：

```markdown
**涉及文件:**
| 文件 | 改动类型 | 说明 |
|------|----------|------|
| `handlers/xxx.py` | 新增 | [功能说明] |
| `routes.py` | 修改 | 添加 [XXX] 端点 |
```

### PROJECT_OVERVIEW.md 更新时机：

| 触发条件 | 更新内容 |
|----------|----------|
| 创建新 product/service/infrastructure | 更新对应清单 |
| 模块状态变更（开发中→已完成） | 更新状态列 |
| 目录结构变更 | 更新目录树 |

### CLAUDE.md 更新时机：

| 触发条件 | 更新内容 |
|----------|----------|
| 架构规则变更 | 更新依赖规则、开发原则 |
| 新增全局约束 | 更新禁止事项 |
| 部署配置变更 | 更新服务器信息 |

## 完整工作流循环

```
┌─────────────────────────────────────────────────────────────────┐
│  1. 阅读主文档 + 模块 memory-bank → 执行 Step N                   │
│         ↓                                                       │
│  2. 测试验证（含模块间交互）                                       │
│         ↓                                                       │
│  3. 通过? ─── 否 ──→ 修复 ──→ 返回步骤 2                          │
│         │                                                       │
│        是                                                       │
│         ↓                                                       │
│  4. 更新文档：                                                   │
│     - 主文档 progress.md + architecture.md                       │
│     - 模块 cross-module-refs.md                                  │
│         ↓                                                       │
│  5. Git commit + tag                                            │
│         ↓                                                       │
│  6. 还有步骤? ─── 是 ──→ 返回步骤 1                               │
│         │                                                       │
│        否                                                       │
│         ↓                                                       │
│  7. 功能完成！                                                   │
└─────────────────────────────────────────────────────────────────┘
```

## 每个步骤完成后的检查清单

- [ ] 测试验证通过（含模块间交互）
- [ ] 更新主文档 `docs/features/[功能名]/progress.md`
- [ ] 更新主文档 `docs/features/[功能名]/architecture.md`
- [ ] 更新模块 `memory-bank/cross-module-refs.md`
- [ ] Git commit
- [ ] Git tag
- [ ] 告知用户可继续下一步

## 问题处理

| 场景 | 处理方式 |
|------|----------|
| Bug 修复 | 分析错误原因 → 修复 → 重新测试 → 不继续下一步 |
| 模块间冲突 | 检查依赖关系是否正确，确保下层先完成 |
| 代码回滚 | 使用 `git reset --hard HEAD~1` |
| 卡住时 | 向用户说明尝试过的方法、当前状态，请求帮助分析 |
| 缺失信息 | 暂停开发，向用户询问后再继续 |

## 缺失信息处理（铁律）

开发过程中遇到缺失信息时，**必须暂停并向用户询问**，不要猜测或使用占位符：

| 缺失信息类型 | 示例 | 处理方式 |
|--------------|------|----------|
| 模块间接口 | API 路径、事件名称、数据格式 | 询问用户确认或查阅其他模块文档 |
| API 密钥 | Shopify API Key、Coze Token | 询问用户提供或指明配置位置 |
| 服务 URL | 后端 API 地址、第三方服务地址 | 询问用户确认正确的 URL |
| 环境配置 | 端口号、域名、环境变量 | 询问用户确认配置 |
| 业务规则 | 超时时间、重试次数、阈值 | 询问用户确认业务要求 |

**询问模板：**

```
开发 [功能名] Step [N] 过程中发现以下信息缺失，请提供：

1. [缺失信息1]: [说明为什么需要]
2. [缺失信息2]: [说明为什么需要]

获得信息后我会继续开发。
```

## 生产环境与企业级开发要求

开发始终保证符合生产环境和企业级实际使用标准：

- **健壮性**：代码必须经过充分测试，处理边界情况和异常
- **安全性**：遵循安全最佳实践，避免常见漏洞（XSS、CSRF、注入等）
- **可维护性**：代码结构清晰，遵循项目既定规范
- **高并发**：考虑多用户并发场景，避免竞态条件
- **容错性**：优雅处理外部服务失败，提供降级方案
- **模块解耦**：通过 services 层通信，禁止产品层直接依赖

## 禁止事项（铁律）

- ❌ 禁止跳过下层直接开发上层（必须 infrastructure → services → products）
- ❌ 禁止产品层直接 import 另一个产品
- ❌ 禁止跳过测试就提交代码
- ❌ 禁止一次改动太多文件（>10 个）
- ❌ 禁止一次改动太多代码（>500 行）
- ❌ 禁止忘记更新主文档和模块引用
- ❌ 禁止未经用户确认就提交代码
- ❌ 禁止未经用户确认就部署到服务器
- ❌ 禁止使用临时方案替代生产级实现
